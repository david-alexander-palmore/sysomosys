<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make sure viewport scales correctly on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Osmos Clone - Touch Enabled</title> <!-- Updated Title -->
    <style>
        /* Basic body and canvas styles */
        body { margin: 0; overflow: hidden; background-color: #000510; display: flex; justify-content: center; align-items: center; height: 100vh; position: relative; /* Needed for absolute positioning context if menu was inside body */ }
        canvas {
            display: block;
            /* Prevent unwanted text selection, etc. on touch */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Improve touch responsiveness */
            touch-action: none;
         }

         /* --- Hamburger Menu Styles --- */
         #hamburger-menu {
            position: fixed; /* Position relative to the viewport */
            top: 15px;
            right: 15px;
            width: 30px;
            height: 25px;
            cursor: pointer;
            z-index: 1000; /* Ensure it's above the canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px; /* Add some padding for easier tapping */
            box-sizing: border-box; /* Include padding in width/height */
         }

         #hamburger-menu span {
            display: block;
            width: 100%;
            height: 3px; /* Line thickness */
            background-color: #ffffff; /* White lines */
            border-radius: 2px;
            transition: background-color 0.2s ease-in-out; /* Smooth hover effect */
         }

        /* Optional: Slightly change color on hover */
         #hamburger-menu:hover span {
             background-color: #cccccc;
         }

        /* Hide menu when in fullscreen? Optional, but can be cleaner */
        :fullscreen #hamburger-menu {
            /* display: none; */ /* Uncomment this line if you want to hide it */
        }
        :-webkit-full-screen #hamburger-menu { /* Safari */
            /* display: none; */
        }
        :-ms-fullscreen #hamburger-menu { /* IE11 */
            /* display: none; */
        }

    </style>
</head>
<body>
    <!-- The Hamburger Menu Button -->
    <div id="hamburger-menu" title="Toggle Fullscreen">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Settings ---
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const MIN_PLAYER_RADIUS = 5;
        const EJECTION_MASS_RATIO = 0.025;
        const EJECTION_SPEED_MULTIPLIER = 200;
        const INITIAL_ORBS = 40;
        const MAX_ORB_RADIUS = 45;
        const MIN_ORB_RADIUS = 2;
        const SAFE_ZONE_RADIUS = 30;
        const MASS_ABSORPTION_RATIO = 1.01; // Must be > 1 for absorption
        const PROPULSION_COOLDOWN = 80;
        const PLAYER_PULSE_FREQ_HZ = 0.33;
        const PLAYER_PULSE_AMPLITUDE = 0.2;
        const BASE_ABSORPTION_RATE_PER_SECOND = 100;
        const MAX_OVERLAP_SPEED_FACTOR = 4;
        const VELOCITY_ABSORPTION_FACTOR = 60;
        const MIN_ABSORB_COMPLETE_RADIUS = 0.5;
        const FIXED_TIMESTEP_MS = 1000 / 120;
        const FIXED_TIMESTEP_S = FIXED_TIMESTEP_MS / 1000.0;
        const MAX_ACCUMULATED_TIME_MS = 100;
        const INITIAL_ORB_MAX_SPEED = 3;

        // --- Game State ---
        let player = null;
        let orbs = [];
        let animationFrameId = null;
        let isInteractionActive = false; // Renamed from isMouseDown for clarity
        let lastInteractionX = 0;      // Renamed from lastMouseX
        let lastInteractionY = 0;      // Renamed from lastMouseY
        let lastPropulsionTime = 0;
        let lastTimestamp = 0;
        let timeAccumulator = 0;
        let activeAbsorptions = new Map();
        let orbsToRemove = new Set();

        // --- Helper Functions ---
        function getRandomColor() { const r = Math.floor(Math.random() * 155) + 100; const g = Math.floor(Math.random() * 155) + 100; const b = Math.floor(Math.random() * 155) + 100; const a = (Math.random() * 0.3 + 0.6).toFixed(2); return `rgba(${r}, ${g}, ${b}, ${a})`; }
        function parseRGBA(rgbaString) { if (!rgbaString) return { r: 128, g: 128, b: 128, a: 0.8 }; const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/); if (match) { return { r: parseInt(match[1], 10), g: parseInt(match[2], 10), b: parseInt(match[3], 10), a: match[4] !== undefined ? parseFloat(match[4]) : 1.0 }; } console.warn("Could not parse RGBA string:", rgbaString); return { r: 128, g: 128, b: 128, a: 0.8 }; }
        function wrappedDistance(x1, y1, x2, y2, width, height) { let dx = Math.abs(x1 - x2); let dy = Math.abs(y1 - y2); if (dx > width / 2) { dx = width - dx; } if (dy > height / 2) { dy = height - dy; } return Math.sqrt(dx * dx + dy * dy); }
        function getWrappedVector(x1, y1, x2, y2, width, height) { let dx = x2 - x1; let dy = y2 - y1; if (Math.abs(dx) > width / 2) { dx = dx > 0 ? dx - width : dx + width; } if (Math.abs(dy) > height / 2) { dy = dy > 0 ? dy - height : dy + height; } return { dx, dy }; }

        // --- Orb Object Creation ---
        function createOrb(x, y, radius, dx = 0, dy = 0, color = getRandomColor()) {
            if (typeof MIN_ABSORB_COMPLETE_RADIUS === 'undefined') { console.error("CRITICAL: MIN_ABSORB_COMPLETE_RADIUS is not defined!"); return undefined; }
            const validRadius = Math.max(MIN_ABSORB_COMPLETE_RADIUS, radius);
            if (isNaN(validRadius)) { console.error(`CRITICAL: validRadius became NaN! Input: ${radius}`); return undefined; }
            const mass = validRadius * validRadius;
            return { id: Math.random().toString(36).substring(2, 9) + Date.now(), x, y, radius: validRadius, dx, dy, color, mass: mass, isPlayer: false };
        }

        // --- Drawing Functions ---
        function _drawSingleOrbInstance(drawX, drawY, radius, color, shadowColor, shadowBlur) { if (radius < MIN_ABSORB_COMPLETE_RADIUS) return; if (drawX + radius < 0 || drawX - radius > canvasWidth || drawY + radius < 0 || drawY - radius > canvasHeight) { return; } ctx.beginPath(); ctx.arc(drawX, drawY, radius, 0, Math.PI * 2); ctx.shadowColor = shadowColor; ctx.shadowBlur = shadowBlur; ctx.fillStyle = color; ctx.fill(); }
        function drawOrbWithWrapping(orb, drawOffsetX, drawOffsetY) { if (!orb || orb.radius < MIN_ABSORB_COMPLETE_RADIUS || orbsToRemove.has(orb.id)) return; const drawX = orb.x - drawOffsetX; const drawY = orb.y - drawOffsetY; const drawRadius = orb.radius; let drawColor = orb.color; let baseShadowColor = orb.color; if (orb.isPlayer) { const baseColor = parseRGBA(orb.color); const timeSeconds = Date.now() / 1000; const pulseFactor = 1.0 + PLAYER_PULSE_AMPLITUDE * Math.sin(2 * Math.PI * PLAYER_PULSE_FREQ_HZ * timeSeconds); const newR = Math.max(0, Math.min(255, Math.round(baseColor.r * pulseFactor))); const newG = Math.max(0, Math.min(255, Math.round(baseColor.g * pulseFactor))); const newB = Math.max(0, Math.min(255, Math.round(baseColor.b * pulseFactor))); drawColor = `rgba(${newR}, ${newG}, ${newB}, ${baseColor.a})`; baseShadowColor = drawColor; } const glowAmount = Math.min(drawRadius * 0.7, 15); const shadowBlur = glowAmount > 1 ? glowAmount : 0; const shadowColor = baseShadowColor; _drawSingleOrbInstance(drawX, drawY, drawRadius, drawColor, shadowColor, shadowBlur); const worldWidth = canvasWidth; const worldHeight = canvasHeight; let wrapDrawX = drawX, wrapDrawY = drawY; let wrappedHorizontal = false, wrappedVertical = false; if (drawX - drawRadius < 0) { _drawSingleOrbInstance(drawX + worldWidth, drawY, drawRadius, drawColor, shadowColor, shadowBlur); wrappedHorizontal = true; wrapDrawX = drawX + worldWidth; } if (drawX + drawRadius > canvasWidth) { _drawSingleOrbInstance(drawX - worldWidth, drawY, drawRadius, drawColor, shadowColor, shadowBlur); wrappedHorizontal = true; wrapDrawX = drawX - worldWidth; } if (drawY - drawRadius < 0) { _drawSingleOrbInstance(drawX, drawY + worldHeight, drawRadius, drawColor, shadowColor, shadowBlur); wrappedVertical = true; wrapDrawY = drawY + worldHeight; } if (drawY + drawRadius > canvasHeight) { _drawSingleOrbInstance(drawX, drawY - worldHeight, drawRadius, drawColor, shadowColor, shadowBlur); wrappedVertical = true; wrapDrawY = drawY - worldHeight; } if (wrappedHorizontal && wrappedVertical) { const cornerX = (drawX - drawRadius < 0) ? drawX + worldWidth : drawX - worldWidth; const cornerY = (drawY - drawRadius < 0) ? drawY + worldHeight : drawY - worldHeight; _drawSingleOrbInstance(cornerX, cornerY, drawRadius, drawColor, shadowColor, shadowBlur); } ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; }

        // --- Update Functions ---
        function updateOrb(orb, dtSeconds) {
            if (!orb || dtSeconds <= 0) return;
            orb.x += orb.dx * dtSeconds;
            orb.y += orb.dy * dtSeconds;
            if (orb.x >= canvasWidth) orb.x -= canvasWidth; else if (orb.x < 0) orb.x += canvasWidth;
            if (orb.y >= canvasHeight) orb.y -= canvasHeight; else if (orb.y < 0) orb.y += canvasHeight;
            if (!activeAbsorptions.has(orb.id) && orb.mass < (MIN_PLAYER_RADIUS * MIN_PLAYER_RADIUS * 0.01)) { orb.mass = Math.max(0.01, orb.mass); orb.radius = Math.sqrt(orb.mass); }
            if (orb.isPlayer && orb.radius < MIN_PLAYER_RADIUS) { orb.radius = MIN_PLAYER_RADIUS; orb.mass = orb.radius * orb.radius; }
        }

        // --- Collision & Absorption Logic ---
        function mixMomentumOnAbsorption(absorber, absorbed, absorbedOriginalMass) {
             const totalMass = absorber.mass; const absorberOriginalMass = totalMass - absorbedOriginalMass;
             if (totalMass <= 0 || absorberOriginalMass < 0 || absorbedOriginalMass <= 0) { console.warn("Invalid mass in momentum mixing:", totalMass, absorberOriginalMass, absorbedOriginalMass); return; }
             const finalMass = absorber.mass; const initialAbsorberMass = finalMass - absorbedOriginalMass;
             if (finalMass > 0) { absorber.dx = (initialAbsorberMass * absorber.dx + absorbedOriginalMass * absorbed.dx) / finalMass; absorber.dy = (initialAbsorberMass * absorber.dy + absorbedOriginalMass * absorbed.dy) / finalMass; }
             else { absorber.dx = 0; absorber.dy = 0; }
        }
        function updateAbsorptions(fixedTimestepMs) {
            if (fixedTimestepMs <= 0) return;
            const dtSeconds = fixedTimestepMs / 1000.0;
            for (let [absorbedId, absorptionInfo] of activeAbsorptions) {
                const { absorber, absorbed } = absorptionInfo;
                const currentAbsorber = absorber.isPlayer ? player : orbs.find(o => o.id === absorber.id);
                const currentAbsorbed = absorbed.isPlayer ? player : orbs.find(o => o.id === absorbed.id);
                if (!currentAbsorber || orbsToRemove.has(absorber.id) || !currentAbsorbed || orbsToRemove.has(absorbed.id)) { activeAbsorptions.delete(absorbedId); continue; }
                const dist = wrappedDistance(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight);
                const radiiSum = currentAbsorber.radius + currentAbsorbed.radius; const overlap = Math.max(0, radiiSum - dist);
                if (overlap >= 0 && dist <= radiiSum + 0.1 && currentAbsorber.mass > currentAbsorbed.mass * MASS_ABSORPTION_RATIO && currentAbsorbed.radius >= MIN_ABSORB_COMPLETE_RADIUS * 0.9) {
                    let approachSpeed = 0; if (dist > 0.1) { const v_rel_x = currentAbsorbed.dx - currentAbsorber.dx; const v_rel_y = currentAbsorbed.dy - currentAbsorber.dy; const disp = getWrappedVector(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const dispMag = Math.sqrt(disp.dx * disp.dx + disp.dy * disp.dy); if (dispMag > 0.01) { const unit_x = disp.dx / dispMag; const unit_y = disp.dy / dispMag; const v_radial = v_rel_x * unit_x + v_rel_y * unit_y; approachSpeed = Math.max(0, -v_radial); } }
                    const overlapRatio = currentAbsorbed.radius > 0.1 ? Math.min(1, overlap / currentAbsorbed.radius) : 1; const overlapFactor = overlapRatio * (MAX_OVERLAP_SPEED_FACTOR - 1.0); const velocityFactor = approachSpeed * (VELOCITY_ABSORPTION_FACTOR / BASE_ABSORPTION_RATE_PER_SECOND); const speedFactor = 1.0 + overlapFactor + velocityFactor; const effectiveAbsorptionRate = BASE_ABSORPTION_RATE_PER_SECOND * speedFactor;
                    let massToTransfer = effectiveAbsorptionRate * dtSeconds; massToTransfer = Math.min(massToTransfer, currentAbsorbed.mass);
                    const oldAbsorberMass = currentAbsorber.mass; const massBeingTransferred = massToTransfer;
                    if (massBeingTransferred > 0) {
                        currentAbsorber.mass += massBeingTransferred; currentAbsorbed.mass -= massBeingTransferred;
                        currentAbsorber.radius = Math.sqrt(currentAbsorber.mass); currentAbsorbed.radius = currentAbsorbed.mass > 0 ? Math.sqrt(currentAbsorbed.mass) : 0;
                        const c1 = parseRGBA(currentAbsorber.color); const c2 = parseRGBA(currentAbsorbed.color); const newTotalMass = currentAbsorber.mass;
                        if (newTotalMass > 0) { const newR = Math.round((c1.r * oldAbsorberMass + c2.r * massBeingTransferred) / newTotalMass); const newG = Math.round((c1.g * oldAbsorberMass + c2.g * massBeingTransferred) / newTotalMass); const newB = Math.round((c1.b * oldAbsorberMass + c2.b * massBeingTransferred) / newTotalMass); const newA = (c1.a * oldAbsorberMass + c2.a * massBeingTransferred) / newTotalMass; currentAbsorber.color = `rgba(${Math.max(0,Math.min(255,newR))}, ${Math.max(0,Math.min(255,newG))}, ${Math.max(0,Math.min(255,newB))}, ${Math.max(0.1,Math.min(1,newA)).toFixed(2)})`; }
                    }
                    const newRadiiSum = currentAbsorber.radius + currentAbsorbed.radius; const newDist = wrappedDistance(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const penetration = Math.max(0, newRadiiSum - newDist);
                    if (penetration > 0.05 && newDist > 0.05) { const vector = getWrappedVector(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const vectorMag = Math.sqrt(vector.dx * vector.dx + vector.dy * vector.dy); if (vectorMag > 0.01) { const nudgeFactor = penetration / vectorMag; const totalMassForNudge = currentAbsorber.mass + currentAbsorbed.mass; if (totalMassForNudge > 0.01) { const nudgeAbsorbedX = vector.dx * nudgeFactor * (currentAbsorber.mass / totalMassForNudge); const nudgeAbsorbedY = vector.dy * nudgeFactor * (currentAbsorber.mass / totalMassForNudge); const nudgeAbsorberX = -vector.dx * nudgeFactor * (currentAbsorbed.mass / totalMassForNudge); const nudgeAbsorberY = -vector.dy * nudgeFactor * (currentAbsorbed.mass / totalMassForNudge); currentAbsorbed.x = (currentAbsorbed.x + nudgeAbsorbedX + canvasWidth) % canvasWidth; currentAbsorbed.y = (currentAbsorbed.y + nudgeAbsorbedY + canvasHeight) % canvasHeight; currentAbsorber.x = (currentAbsorber.x + nudgeAbsorberX + canvasWidth) % canvasWidth; currentAbsorber.y = (currentAbsorber.y + nudgeAbsorberY + canvasHeight) % canvasHeight; } } }
                    if (currentAbsorbed.radius < MIN_ABSORB_COMPLETE_RADIUS || currentAbsorbed.mass <= 0.01) { const remainingMass = currentAbsorbed.mass; if (remainingMass > 0) { currentAbsorber.mass += remainingMass; currentAbsorber.radius = Math.sqrt(currentAbsorber.mass); } mixMomentumOnAbsorption(currentAbsorber, currentAbsorbed, massBeingTransferred + remainingMass); orbsToRemove.add(absorbedId); activeAbsorptions.delete(absorbedId); currentAbsorbed.mass = 0; currentAbsorbed.radius = 0; currentAbsorbed.dx = 0; currentAbsorbed.dy = 0; }
                } else { activeAbsorptions.delete(absorbedId); }
            }
        }
        function checkCollisions() {
             if (!player) return;
             const allOrbs = [player, ...orbs.filter(o => !orbsToRemove.has(o.id))]; const checkedPairs = new Set();
             for (let i = allOrbs.length - 1; i >= 0; i--) {
                 const orb1 = allOrbs[i]; if (!orb1 || orb1.mass <= 0) continue;
                 for (let j = i - 1; j >= 0; j--) {
                     const orb2 = allOrbs[j]; if (!orb2 || orb2.mass <= 0) continue;
                     const pairKey = orb1.id < orb2.id ? `${orb1.id}-${orb2.id}` : `${orb2.id}-${orb1.id}`; if (checkedPairs.has(pairKey)) continue; checkedPairs.add(pairKey);
                     const dist = wrappedDistance(orb1.x, orb1.y, orb2.x, orb2.y, canvasWidth, canvasHeight); const radiiSum = orb1.radius + orb2.radius;
                     if (dist <= radiiSum + 0.5) {
                         let absorber = null, absorbed = null;
                         if (orb1.mass > orb2.mass * MASS_ABSORPTION_RATIO && orb1.radius > orb2.radius) { absorber = orb1; absorbed = orb2; }
                         else if (orb2.mass > orb1.mass * MASS_ABSORPTION_RATIO && orb2.radius > orb1.radius) { absorber = orb2; absorbed = orb1; }
                         if (absorber && absorbed) { if (absorbed.isPlayer) { console.log(`Game Over - Absorbed by ${absorber.id}`); init(); return; } const reverseAbsorption = activeAbsorptions.get(absorber.id); if (reverseAbsorption && reverseAbsorption.absorber.id === absorbed.id) { activeAbsorptions.delete(absorber.id); } const existingAbsorption = activeAbsorptions.get(absorbed.id); if (!existingAbsorption || existingAbsorption.absorber.id !== absorber.id) { activeAbsorptions.set(absorbed.id, { absorber: absorber, absorbed: absorbed }); } }
                     } else { const absorption12 = activeAbsorptions.get(orb2.id); if (absorption12 && absorption12.absorber.id === orb1.id) { activeAbsorptions.delete(orb2.id); } const absorption21 = activeAbsorptions.get(orb1.id); if (absorption21 && absorption21.absorber.id === orb2.id) { activeAbsorptions.delete(orb1.id); } }
                 }
             }
        }

        // --- Player Control ---
        function propelPlayer(targetScreenX, targetScreenY) {
            if (!player || player.radius <= MIN_PLAYER_RADIUS) return false;
            const targetWorldX = player.x + (targetScreenX - canvasWidth / 2);
            const targetWorldY = player.y + (targetScreenY - canvasHeight / 2);
            const vec = getWrappedVector(player.x, player.y, targetWorldX, targetWorldY, canvasWidth, canvasHeight);
            let dx = vec.dx; let dy = vec.dy; if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) return false;
            const angleToTarget = Math.atan2(dy, dx);
            const ejectionAngle = angleToTarget; const propulsionAngle = angleToTarget + Math.PI;
            const massToEject = player.mass * EJECTION_MASS_RATIO; if (massToEject <= 0) return false;
            const radiusEjected = Math.sqrt(massToEject); if (radiusEjected < MIN_ORB_RADIUS * 0.5) return false;
            const potentialNewPlayerMass = player.mass - massToEject; if (potentialNewPlayerMass < (MIN_PLAYER_RADIUS * MIN_PLAYER_RADIUS)) { return false; }
            const baseEjectionSpeed = EJECTION_SPEED_MULTIPLIER;
            const ejectVelX = player.dx + Math.cos(ejectionAngle) * baseEjectionSpeed; const ejectVelY = player.dy + Math.sin(ejectionAngle) * baseEjectionSpeed;
            const playerNewRadiusIfEjected = Math.sqrt(potentialNewPlayerMass); const effectivePlayerRadiusForPlacement = Math.max(MIN_PLAYER_RADIUS, playerNewRadiusIfEjected);
            const startDist = effectivePlayerRadiusForPlacement + radiusEjected + 1.5;
            const ejectStartRawX = player.x + Math.cos(ejectionAngle) * startDist; const ejectStartRawY = player.y + Math.sin(ejectionAngle) * startDist;
            const ejectStartX = (ejectStartRawX % canvasWidth + canvasWidth) % canvasWidth; const ejectStartY = (ejectStartRawY % canvasHeight + canvasHeight) % canvasHeight;
            const playerBaseColor = parseRGBA(player.color); const ejectAlpha = Math.max(0.2, playerBaseColor.a * 0.7).toFixed(2);
            const ejectColor = `rgba(${playerBaseColor.r}, ${playerBaseColor.g}, ${playerBaseColor.b}, ${ejectAlpha})`;
            const particle = createOrb(ejectStartX, ejectStartY, radiusEjected, ejectVelX, ejectVelY, ejectColor);
            if (particle && particle.mass > 0) { orbs.push(particle); } else { console.warn("Ejected particle invalid mass or creation failed."); return false; }
            player.mass = potentialNewPlayerMass; player.radius = Math.max(MIN_PLAYER_RADIUS, Math.sqrt(player.mass));
            const impulseMagnitude = massToEject * baseEjectionSpeed; if (player.mass > 0) { const thrustX = Math.cos(propulsionAngle) * impulseMagnitude / player.mass; const thrustY = Math.sin(propulsionAngle) * impulseMagnitude / player.mass; player.dx += thrustX; player.dy += thrustY; }
            return true;
        }

        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (!lastTimestamp) lastTimestamp = currentTime;
            let deltaTime = currentTime - lastTimestamp; lastTimestamp = currentTime;

            // Use the unified interaction flag and coordinates
            if (isInteractionActive && player) {
                if (currentTime - lastPropulsionTime > PROPULSION_COOLDOWN) {
                    if (propelPlayer(lastInteractionX, lastInteractionY)) { // Use renamed vars
                        lastPropulsionTime = currentTime;
                    }
                }
            }
            timeAccumulator += deltaTime; timeAccumulator = Math.min(timeAccumulator, MAX_ACCUMULATED_TIME_MS);
            while (timeAccumulator >= FIXED_TIMESTEP_MS) {
                if (player) updateOrb(player, FIXED_TIMESTEP_S);
                orbs.forEach(orb => { if (!orbsToRemove.has(orb.id)) updateOrb(orb, FIXED_TIMESTEP_S); });
                updateAbsorptions(FIXED_TIMESTEP_MS);
                timeAccumulator -= FIXED_TIMESTEP_MS;
             }
            checkCollisions();
            if (orbsToRemove.size > 0) { orbs = orbs.filter(orb => !orbsToRemove.has(orb.id)); activeAbsorptions.forEach((value, key) => { if (orbsToRemove.has(key)) { activeAbsorptions.delete(key); } }); orbsToRemove.clear(); }

            // --- Drawing ---
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (player) {
                 const drawOffsetX = player.x - canvasWidth / 2; const drawOffsetY = player.y - canvasHeight / 2;
                 ctx.save();
                 orbs.forEach(orb => drawOrbWithWrapping(orb, drawOffsetX, drawOffsetY));
                 drawOrbWithWrapping(player, drawOffsetX, drawOffsetY);
                 ctx.restore();
            } else { ctx.save(); orbs.forEach(orb => drawOrbWithWrapping(orb, canvasWidth / 2, canvasHeight / 2)); ctx.restore(); }

            // --- Continue Animation ---
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        function spawnOrbs(count) { console.log(`Spawning ${count} orbs... Max speed: ${INITIAL_ORB_MAX_SPEED}`); const existingOrbsAndPlayer = player ? [...orbs, player] : [...orbs]; let spawnedCount = 0; for (let i = 0; i < count; i++) { let r, x, y; let tooClose; let attempts = 0; const maxAttempts = 100; do { r = Math.random() * (MAX_ORB_RADIUS - MIN_ORB_RADIUS) + MIN_ORB_RADIUS; x = Math.random() * canvasWidth; y = Math.random() * canvasHeight; tooClose = false; for (const existing of existingOrbsAndPlayer) { const checkDist = wrappedDistance(x, y, existing.x, existing.y, canvasWidth, canvasHeight); const requiredDist = (existing.radius + r) * 1.1 + (existing.isPlayer ? SAFE_ZONE_RADIUS : 5); if (checkDist < requiredDist) { tooClose = true; break; } } attempts++; } while (tooClose && attempts < maxAttempts); if (!tooClose) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * INITIAL_ORB_MAX_SPEED; const newOrb = createOrb(x, y, r, Math.cos(angle) * speed, Math.sin(angle) * speed); if (newOrb) { orbs.push(newOrb); existingOrbsAndPlayer.push(newOrb); spawnedCount++; } } } console.log(`Successfully spawned ${spawnedCount} / ${count} orbs.`); }
        function init(isResize = false) { // Add flag to know if it's a resize call
            console.log(`Initializing game (Touch Enabled)... ${isResize ? '(Resize)' : ''}`);
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            if (!canvas || !ctx) { console.error("CRITICAL: Canvas or context missing!"); return; }

            // Store previous dimensions if resizing
            const prevWidth = canvasWidth;
            const prevHeight = canvasHeight;

            try { canvasWidth = window.innerWidth; canvasHeight = window.innerHeight; canvas.width = canvasWidth; canvas.height = canvasHeight; } catch (e) { console.error("Error setting canvas dimensions:", e); return; }

            // Only fully reset if not resizing (or if player doesn't exist)
            if (!isResize || !player) {
                 console.log("Full reset required.");
                 orbs = [];
                 player = null;
                 activeAbsorptions.clear();
                 orbsToRemove.clear();
                 console.log("Attempting to create player orb...");
                 player = createOrb(canvasWidth / 2, canvasHeight / 2, 20, 0, 0, 'rgba(100, 200, 255, 0.9)');
                 if (!player || typeof player !== 'object') { console.error("CRITICAL ERROR: Player creation failed!"); return; }
                 console.log("Player object created.");
                 player.isPlayer = true;
                 spawnOrbs(INITIAL_ORBS);
            } else {
                 // Adjust positions based on resize factor (optional, could just center player)
                 const scaleX = canvasWidth / prevWidth;
                 const scaleY = canvasHeight / prevHeight;
                 console.log(`Rescaling positions: ScaleX=${scaleX.toFixed(2)}, ScaleY=${scaleY.toFixed(2)}`);

                 // --- Simple approach: Re-center player ---
                 player.x = canvasWidth / 2;
                 player.y = canvasHeight / 2;
                 // --- More complex: Scale all orb positions (might look weird) ---
                 // player.x *= scaleX;
                 // player.y *= scaleY;
                 // orbs.forEach(orb => {
                 //    orb.x *= scaleX;
                 //    orb.y *= scaleY;
                 //    // Ensure they stay within new bounds (optional, wrapping handles it)
                 //    // orb.x = (orb.x % canvasWidth + canvasWidth) % canvasWidth;
                 //    // orb.y = (orb.y % canvasHeight + canvasHeight) % canvasHeight;
                 // });

                 // Clear absorptions as distances/overlaps changed drastically
                 activeAbsorptions.clear();
                 orbsToRemove.clear(); // Should be empty but good practice
            }

            // Reset interaction state and timing regardless
            isInteractionActive = false;
            lastTimestamp = 0;
            timeAccumulator = 0;

            console.log("Initialization complete, requesting loop...");
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        // --- Event Listeners (Mouse & Touch) ---

        // Helper to get coordinates relative to canvas
        function getCanvasCoordinates(event) {
            // Check if the event target is the menu - if so, ignore for game input
            if (event.target && event.target.closest && event.target.closest('#hamburger-menu')) {
                return null;
            }

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX; // Use first touch point
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else { // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }

            if (clientX === undefined || clientY === undefined) return null;

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // --- Interaction Start (Mouse Down or Touch Start) ---
        function handleInteractionStart(event) {
            const coords = getCanvasCoordinates(event);
            if (!coords) return; // Exit if we couldn't get coordinates (or event was on menu)

             // For touch on canvas, prevent default browser actions like scrolling
             if (event.type === 'touchstart') {
                 event.preventDefault();
             }

            isInteractionActive = true;
            lastInteractionX = coords.x;
            lastInteractionY = coords.y;

            if (player && Date.now() - lastPropulsionTime > PROPULSION_COOLDOWN) {
                if (propelPlayer(lastInteractionX, lastInteractionY)) {
                    lastPropulsionTime = Date.now();
                }
            }
        }

        // --- Interaction Move (Mouse Move or Touch Move) ---
        function handleInteractionMove(event) {
            if (!isInteractionActive) return;

            const coords = getCanvasCoordinates(event);
            if (!coords) return; // Exit if we couldn't get coordinates (or event was on menu)

            // Prevent scrolling while dragging finger on canvas
             if (event.type === 'touchmove') {
                 event.preventDefault();
             }

            lastInteractionX = coords.x;
            lastInteractionY = coords.y;
        }

        // --- Interaction End (Mouse Up, Mouse Leave, Touch End, Touch Cancel) ---
        function handleInteractionEnd(event) {
             // No need to check coords here, just end the active state
             // Prevent default only if it was a touch ending on the canvas
             const targetIsCanvas = !event.target || !event.target.closest || !event.target.closest('#hamburger-menu');
             if (targetIsCanvas && (event.type === 'touchend' || event.type === 'touchcancel')) {
                 // Check if preventDefault is allowed/needed. If the touch started on canvas, it likely is.
                 // This check might be overly cautious but safe.
                 if (event.cancelable) {
                     event.preventDefault();
                 }
             }
            isInteractionActive = false;
        }

        // --- Attach Game Interaction Listeners ---
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        // Use window for mouseup/leave to catch dragging off canvas
        window.addEventListener('mouseup', handleInteractionEnd); // Changed from canvas
        window.addEventListener('mouseleave', handleInteractionEnd); // Added to window

        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        // Use window for touchend/cancel
        window.addEventListener('touchend', handleInteractionEnd, { passive: false }); // Changed from canvas
        window.addEventListener('touchcancel', handleInteractionEnd, { passive: false }); // Changed from canvas


        // --- Resize Listener ---
        // Debounce resize to avoid excessive init calls
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => init(true), 250); // Call init with resize flag after 250ms delay
        });


        // --- Fullscreen Toggle Logic ---
        const hamburgerMenu = document.getElementById('hamburger-menu');
        const docElement = document.documentElement; // Usually the best element to fullscreen

        function isFullScreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }

        function toggleFullScreen() {
            if (!isFullScreen()) {
                console.log("Requesting fullscreen...");
                if (docElement.requestFullscreen) {
                    docElement.requestFullscreen().catch(err => console.error(`Error attempting FScr: ${err.message} (${err.name})`));
                } else if (docElement.webkitRequestFullscreen) { /* Safari */
                    docElement.webkitRequestFullscreen().catch(err => console.error(`Error attempting FScr (webkit): ${err.message} (${err.name})`));
                } else if (docElement.msRequestFullscreen) { /* IE11 */
                    docElement.msRequestFullscreen().catch(err => console.error(`Error attempting FScr (ms): ${err.message} (${err.name})`));
                } else {
                    console.warn("Fullscreen API is not supported by this browser.");
                    // Optionally alert the user
                    // alert("Fullscreen mode is not supported by your browser.");
                }
            } else {
                console.log("Exiting fullscreen...");
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                } else {
                     console.warn("Exit Fullscreen API is not supported?");
                }
            }
        }

        // Attach listener to the menu
        if (hamburgerMenu) {
             hamburgerMenu.addEventListener('click', toggleFullScreen);
             // Also listen for touchstart for better responsiveness on touch devices
             // Use passive: false because we might call preventDefault if needed,
             // but in this simple case, it's unlikely to be needed. Toggling FS doesn't scroll.
             hamburgerMenu.addEventListener('touchstart', (e) => {
                 // e.preventDefault(); // Optional: prevent potential double-tap zoom maybe? Usually not needed here.
                 toggleFullScreen();
             }, { passive: true }); // Can likely be passive=true for this button
        } else {
            console.error("Hamburger menu element not found!");
        }

        // Optional: Listen for fullscreen changes (e.g., user presses ESC)
        // This could be used to update the hamburger icon state if needed
        document.addEventListener('fullscreenchange', () => { console.log('Fullscreen state changed (std)'); });
        document.addEventListener('webkitfullscreenchange', () => { console.log('Fullscreen state changed (webkit)'); });
        document.addEventListener('mozfullscreenchange', () => { console.log('Fullscreen state changed (moz)'); });
        document.addEventListener('MSFullscreenChange', () => { console.log('Fullscreen state changed (ms)'); });


        // --- Start Game ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOMContentLoaded event fired.");
             // Initial game setup
             init(false); // Call init without resize flag initially
        });

    </script>
</body>
</html>
