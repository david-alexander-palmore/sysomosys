<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Osmos Clone + Typing Quotes (Fixed)</title>
    <style>
        /* Basic body and canvas styles */
        body { margin: 0; overflow: hidden; background-color: #000510; display: flex; justify-content: center; align-items: center; height: 100vh; position: relative; }
        canvas {
            display: block;
            -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
            touch-action: none;
         }
         /* --- Hamburger Menu Styles --- */
         #hamburger-menu { position: fixed; top: 15px; right: 15px; width: 30px; height: 25px; cursor: pointer; z-index: 1000; display: flex; flex-direction: column; justify-content: space-between; padding: 5px; box-sizing: border-box; }
         #hamburger-menu span { display: block; width: 100%; height: 3px; background-color: #ffffff; border-radius: 2px; transition: background-color 0.2s ease-in-out; }
         #hamburger-menu:hover span { background-color: #cccccc; }
         /* --- Hide Audio Player --- */
         #background-music { display: none; }
    </style>
</head>
<body>
    <!-- GAME: Elements -->
    <div id="hamburger-menu" title="Toggle Fullscreen">
        <span></span><span></span><span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <audio id="background-music" src="Sysomosys-Vibes.mp3" loop preload="auto"></audio>
    <!-- QUOTE: No separate canvas needed -->
    <!-- QUOTE: Audio object created in JS -->

    <script>
        // --- Shared Canvas & Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Audio ---
        const bgMusic = document.getElementById('background-music');

        // --- Quote Audio ---
        const quoteTypingSound = new Audio('keyclicks.mp3'); // Ensure this file exists
        quoteTypingSound.loop = true;

        // --- Shared Canvas Dimensions ---
        let canvasWidth;
        let canvasHeight;

        // --- Game Settings ---
        const MIN_PLAYER_RADIUS = 5;
        const EJECTION_MASS_RATIO = 0.025;
        const EJECTION_SPEED_MULTIPLIER = 200;
        const INITIAL_ORBS = 40;
        const MAX_ORB_RADIUS = 45;
        const MIN_ORB_RADIUS = 2;
        const SAFE_ZONE_RADIUS = 30;
        const MASS_ABSORPTION_RATIO = 1.01;
        const PROPULSION_COOLDOWN = 80;
        const AUDIO_PULSE_MAX_AMPLITUDE = 0.6;
        const BASE_ABSORPTION_RATE_PER_SECOND = 100;
        const MAX_OVERLAP_SPEED_FACTOR = 4;
        const VELOCITY_ABSORPTION_FACTOR = 60;
        const MIN_ABSORB_COMPLETE_RADIUS = 0.5;
        const FIXED_TIMESTEP_MS = 1000 / 120;
        const FIXED_TIMESTEP_S = FIXED_TIMESTEP_MS / 1000.0;
        const MAX_ACCUMULATED_TIME_MS = 100;
        const INITIAL_ORB_MAX_SPEED = 3;

        // --- Quote Settings ---
        const QUOTE_FONT_SIZE = 24;
        const QUOTE_LINE_HEIGHT = QUOTE_FONT_SIZE * 1.4;
        const QUOTE_FONT_FAMILY = 'monospace';
        const QUOTE_TEXT_COLOR = '#FFFFFF';
        const QUOTE_OUTLINE_COLOR = '#000000';
        const QUOTE_OUTLINE_WIDTH = 3;
        const QUOTE_MAX_CHARS_PER_LINE = 45;
        const QUOTE_TYPING_SPEED_MS = 111; // ~90 WPM
        const QUOTE_TYPO_CHANCE = 0.02;
        const QUOTE_TYPO_DELAY_MS = QUOTE_TYPING_SPEED_MS * 2.0;
        const QUOTE_BACKSPACE_DELAY_MS = QUOTE_TYPING_SPEED_MS * 1.5;
        const QUOTE_PAUSE_DURATION_MS = 5000;  // 5s pause after typing (before fade)
        const QUOTE_FADE_DURATION_MS = 1500;   // 1.5s fade out
        // ***** REMEMBER TO CHANGE THIS BACK TO 45000 WHEN READY *****
        const QUOTE_INTER_QUOTE_PAUSE_MS = 100; // TEMPORARILY 0.1s pause BETWEEN quotes
        const QUOTE_PADDING = 50;
        const QUOTE_CENTER_EXCLUSION_FACTOR_X = 0.3;
        const QUOTE_CENTER_EXCLUSION_FACTOR_Y = 0.4;
        const QUOTE_MAX_PLACEMENT_ATTEMPTS = 10;

        // --- Game State ---
        let player = null;
        let orbs = [];
        let gameAnimationFrameId = null;
        let isInteractionActive = false;
        let lastInteractionX = 0;
        let lastInteractionY = 0;
        let lastPropulsionTime = 0;
        let gameLastTimestamp = 0;
        let gameTimeAccumulator = 0;
        let activeAbsorptions = new Map();
        let orbsToRemove = new Set();
        let playerAbsorbed = false;
        let musicStarted = false;

        // --- Quote State ---
        let quotesData = [];
        let currentQuote = null;
        let quoteState = 'ready_to_load';
        let quoteNextQuoteTimeoutId = null;
        let quoteInitialLoadComplete = false;

        // --- Web Audio API State (Game Music Analysis) ---
        let audioContext = null;
        let analyser = null;
        let sourceNode = null;
        let audioDataArray = null;
        const ANALYSER_FFT_SIZE = 256;
        const ANALYSER_SMOOTHING = 0.5;

        // --- Helper Functions (Both Game & Quote) ---
        function getRandomColor() { const r = Math.floor(Math.random() * 155) + 100; const g = Math.floor(Math.random() * 155) + 100; const b = Math.floor(Math.random() * 155) + 100; const a = (Math.random() * 0.3 + 0.6).toFixed(2); return `rgba(${r}, ${g}, ${b}, ${a})`; }
        function parseRGBA(rgbaString) { if (!rgbaString) return { r: 128, g: 128, b: 128, a: 0.8 }; const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/); if (match) { return { r: parseInt(match[1], 10), g: parseInt(match[2], 10), b: parseInt(match[3], 10), a: match[4] !== undefined ? parseFloat(match[4]) : 1.0 }; } console.warn("Could not parse RGBA string:", rgbaString); return { r: 128, g: 128, b: 128, a: 0.8 }; }
        function wrappedDistance(x1, y1, x2, y2, width, height) { let dx = Math.abs(x1 - x2); let dy = Math.abs(y1 - y2); if (dx > width / 2) { dx = width - dx; } if (dy > height / 2) { dy = height - dy; } return Math.sqrt(dx * dx + dy * dy); }
        function getWrappedVector(x1, y1, x2, y2, width, height) { let dx = x2 - x1; let dy = y2 - y1; if (Math.abs(dx) > width / 2) { dx = dx > 0 ? dx - width : dx + width; } if (Math.abs(dy) > height / 2) { dy = dy > 0 ? dy - height : dy + height; } return { dx, dy }; }

        // QUOTE: CSV Parsing
        function quoteParseCSV(csvText) { /* ... quote's parseCSV function ... */
             const lines = csvText.trim().split('\n'); const parsedQuotes = [];
            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                const firstCommaIndex = line.indexOf(',');
                if (firstCommaIndex === -1) { console.warn(`QUOTE: Skipping invalid CSV line: "${line}"`); return; }
                let authorRaw = line.substring(0, firstCommaIndex); let quoteRaw = line.substring(firstCommaIndex + 1);
                const cleanField = (str) => { let cleaned = str.trim(); if ((cleaned.startsWith('"') && cleaned.endsWith('"')) || (cleaned.startsWith("'") && cleaned.endsWith("'"))) cleaned = cleaned.substring(1, cleaned.length - 1); cleaned = cleaned.replace(/""/g, '"'); return cleaned; };
                let author = cleanField(authorRaw); let quote = cleanField(quoteRaw);
                if (!author) author = "Anonymous"; if (!quote) { console.warn(`QUOTE: Skipping line ${index + 1} with empty quote: "${line}"`); return; }
                parsedQuotes.push({ author, quote });
            }); return parsedQuotes;
        }

        // QUOTE: Text Formatting
        function quoteFormatText(quote, author) { /* ... quote's formatQuoteText function ... */
            ctx.font = `${QUOTE_FONT_SIZE}px ${QUOTE_FONT_FAMILY}`;
            const words = quote.split(' '); const quoteLines = []; let currentLine = '';
            for (let i = 0; i < words.length; i++) {
                const word = words[i]; if (!word) continue;
                const potentialLine = currentLine ? `${currentLine} ${word}` : word;
                if (potentialLine.length <= QUOTE_MAX_CHARS_PER_LINE) { currentLine = potentialLine; }
                else {
                    if (currentLine.length > 0) { quoteLines.push(currentLine); }
                    currentLine = word;
                    if (word.length > QUOTE_MAX_CHARS_PER_LINE && quoteLines.length > 0) { console.warn(`QUOTE: Single word "${word}" exceeds MAX_CHARS_PER_LINE (${QUOTE_MAX_CHARS_PER_LINE})`); }
                    else if (word.length > QUOTE_MAX_CHARS_PER_LINE && quoteLines.length === 0) { console.warn(`QUOTE: First word "${word}" exceeds MAX_CHARS_PER_LINE (${QUOTE_MAX_CHARS_PER_LINE}).`); }
                }
            }
            if (currentLine) { quoteLines.push(currentLine); }
            else if (quoteLines.length === 0 && quote) { console.warn("QUOTE: Formatting resulted in empty quoteLines:", quote); }
            const authorLine = `—${author}`; let maxQuoteLineWidth = 0;
            quoteLines.forEach(line => { const lineWidth = ctx.measureText(line).width; if (lineWidth > maxQuoteLineWidth) maxQuoteLineWidth = lineWidth; });
            const authorLineWidth = ctx.measureText(authorLine).width;
            return { quoteLines, authorLine, fullText: quoteLines.join('\n') + '\n' + authorLine, maxQuoteLineWidth, authorLineWidth, totalQuoteLines: quoteLines.length };
        }

        // --- Game Orb Creation ---
        function createOrb(x, y, radius, dx = 0, dy = 0, color = getRandomColor()) { /* ... game's function ... */ if (typeof MIN_ABSORB_COMPLETE_RADIUS === 'undefined') { console.error("CRITICAL: MIN_ABSORB_COMPLETE_RADIUS is not defined!"); return undefined; } const validRadius = Math.max(MIN_ABSORB_COMPLETE_RADIUS, radius); if (isNaN(validRadius)) { console.error(`CRITICAL: validRadius became NaN! Input: ${radius}`); return undefined; } const mass = validRadius * validRadius; return { id: Math.random().toString(36).substring(2, 9) + Date.now(), x, y, radius: validRadius, dx, dy, color, mass: mass, isPlayer: false }; }

        // --- Drawing Functions ---
        function _drawSingleOrbInstance(drawX, drawY, radius, color, shadowColor, shadowBlur) { /* ... game's function ... */ if (radius < MIN_ABSORB_COMPLETE_RADIUS) return; if (drawX + radius < 0 || drawX - radius > canvasWidth || drawY + radius < 0 || drawY - radius > canvasHeight) { return; } ctx.beginPath(); ctx.arc(drawX, drawY, radius, 0, Math.PI * 2); ctx.shadowColor = shadowColor; ctx.shadowBlur = shadowBlur; ctx.fillStyle = color; ctx.fill(); }
        function drawOrbWithWrapping(orb, drawOffsetX, drawOffsetY) { /* ... game's function (includes audio pulse) ... */
            if (!orb || orb.radius < MIN_ABSORB_COMPLETE_RADIUS || orbsToRemove.has(orb.id)) return;
            const drawX = orb.x - drawOffsetX; const drawY = orb.y - drawOffsetY; const drawRadius = orb.radius;
            let drawColor = orb.color; let baseShadowColor = orb.color;
            if (orb.isPlayer) {
                const baseColor = parseRGBA(orb.color); let pulseFactor = 1.0;
                if (analyser && audioDataArray) {
                    analyser.getByteFrequencyData(audioDataArray); let sum = 0;
                    const lengthToAverage = Math.floor(audioDataArray.length / 2);
                    if (lengthToAverage > 0) { for(let i = 0; i < lengthToAverage; i++) { sum += audioDataArray[i]; } const average = sum / lengthToAverage; const normalizedVolume = average / 255; pulseFactor = 1.0 + (normalizedVolume * AUDIO_PULSE_MAX_AMPLITUDE); }
                }
                const newR = Math.max(0, Math.min(255, Math.round(baseColor.r * pulseFactor))); const newG = Math.max(0, Math.min(255, Math.round(baseColor.g * pulseFactor))); const newB = Math.max(0, Math.min(255, Math.round(baseColor.b * pulseFactor)));
                drawColor = `rgba(${newR}, ${newG}, ${newB}, ${baseColor.a})`; baseShadowColor = drawColor;
            }
            const glowAmount = Math.min(drawRadius * 0.7, 15); const shadowBlur = glowAmount > 1 ? glowAmount : 0; const shadowColor = baseShadowColor;
            _drawSingleOrbInstance(drawX, drawY, drawRadius, drawColor, shadowColor, shadowBlur);
            const worldWidth = canvasWidth; const worldHeight = canvasHeight; let wrappedHorizontal = false, wrappedVertical = false; if (drawX - drawRadius < 0) { _drawSingleOrbInstance(drawX + worldWidth, drawY, drawRadius, drawColor, shadowColor, shadowBlur); wrappedHorizontal = true; } if (drawX + drawRadius > canvasWidth) { _drawSingleOrbInstance(drawX - worldWidth, drawY, drawRadius, drawColor, shadowColor, shadowBlur); wrappedHorizontal = true; } if (drawY - drawRadius < 0) { _drawSingleOrbInstance(drawX, drawY + worldHeight, drawRadius, drawColor, shadowColor, shadowBlur); wrappedVertical = true; } if (drawY + drawRadius > canvasHeight) { _drawSingleOrbInstance(drawX, drawY - worldHeight, drawRadius, drawColor, shadowColor, shadowBlur); wrappedVertical = true; } if (wrappedHorizontal && wrappedVertical) { const cornerX = (drawX - drawRadius < 0) ? drawX + worldWidth : drawX - worldWidth; const cornerY = (drawY - drawRadius < 0) ? drawY + worldHeight : drawY - worldHeight; _drawSingleOrbInstance(cornerX, cornerY, drawRadius, drawColor, shadowColor, shadowBlur); } ctx.shadowBlur = 0; ctx.shadowColor = 'transparent';
        }

        // QUOTE: Drawing Functions
        function quoteDrawTextWithOutline(text, x, y) { /* ... quote's function ... */ ctx.strokeStyle = QUOTE_OUTLINE_COLOR; ctx.lineWidth = QUOTE_OUTLINE_WIDTH; ctx.strokeText(text, x, y); ctx.fillStyle = QUOTE_TEXT_COLOR; ctx.fillText(text, x, y); }
        function quoteDrawState(quoteObj, alpha = 1.0) { /* ... quote's function ... */ const { x, y, quoteLines, authorLine, typedText, maxQuoteLineWidth, authorLineWidth, totalQuoteLines } = quoteObj; if (typedText === undefined) return; const linesToDraw = typedText.split('\n'); ctx.save(); ctx.globalAlpha = alpha; ctx.font = `${QUOTE_FONT_SIZE}px ${QUOTE_FONT_FAMILY}`; ctx.textBaseline = 'top'; ctx.textAlign = 'left'; ctx.lineJoin = 'round'; for (let i = 0; i < linesToDraw.length; i++) { if (i < totalQuoteLines) quoteDrawTextWithOutline(linesToDraw[i], x, y + i * QUOTE_LINE_HEIGHT); } if (linesToDraw.length > totalQuoteLines) { const authorTextToDraw = linesToDraw[linesToDraw.length - 1] || ''; if(authorTextToDraw) { const authorY = y + totalQuoteLines * QUOTE_LINE_HEIGHT; const authorStartX = x + maxQuoteLineWidth - authorLineWidth; quoteDrawTextWithOutline(authorTextToDraw, authorStartX, authorY); } } ctx.restore(); }
        function quoteDisplayStatusMessage(message) { /* ... quote's function ... */ ctx.save(); ctx.fillStyle = '#888888'; ctx.font = 'italic 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(message, canvasWidth / 2, canvasHeight / 2); ctx.restore(); }
        function quoteDisplayError(message) { /* ... quote's function ... */ ctx.save(); ctx.clearRect(0, 0, canvasWidth, canvasHeight); ctx.fillStyle = '#D32F2F'; ctx.strokeStyle = '#424242'; ctx.lineWidth = 1; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const lines = message.split('. '); const yOffset = - ( (lines.length -1) * 10); lines.forEach((line, index) => { const text = line + (index < lines.length - 1 ? '.' : ''); const yPos = canvasHeight / 2 + (index * 20) + yOffset; ctx.strokeText(text, canvasWidth / 2, yPos); ctx.fillText(text, canvasWidth / 2, yPos); }); ctx.font = '14px sans-serif'; const detailText = "Check console (F12) for details."; const detailY = canvasHeight / 2 + (lines.length * 20) + yOffset + 10; ctx.strokeText(detailText, canvasWidth / 2, detailY); ctx.fillText(detailText, canvasWidth / 2, detailY); ctx.restore(); }

        // --- Game Update Functions ---
        function updateOrb(orb, dtSeconds) { /* ... game's function ... */ if (!orb || dtSeconds <= 0) return; orb.x += orb.dx * dtSeconds; orb.y += orb.dy * dtSeconds; if (orb.x >= canvasWidth) orb.x -= canvasWidth; else if (orb.x < 0) orb.x += canvasWidth; if (orb.y >= canvasHeight) orb.y -= canvasHeight; else if (orb.y < 0) orb.y += canvasHeight; if (!orb.isPlayer && !activeAbsorptions.has(orb.id) && orb.mass < (MIN_ORB_RADIUS * MIN_ORB_RADIUS * 0.1)) { orb.mass = Math.max(0.01, orb.mass); orb.radius = Math.sqrt(orb.mass); } if (orb.isPlayer && orb.radius < MIN_PLAYER_RADIUS && !activeAbsorptions.has(orb.id)) { orb.radius = MIN_PLAYER_RADIUS; orb.mass = orb.radius * orb.radius; } }

        // ***** ADDED MISSING FUNCTION *****
        function mixMomentumOnAbsorption(absorber, absorbed, absorbedOriginalMass) {
            if (!absorber || !absorbed || absorber.mass <= 0 || absorbedOriginalMass <= 0) {
                // Avoid division by zero or invalid operations
                return;
            }

            // Calculate the mass of the absorber *before* this specific transfer step began
            // Note: absorber.mass already includes mass transferred in *previous* steps of this absorption event
            // We need the mass *just before* absorbing 'absorbedOriginalMass'
            const initialAbsorberMass = absorber.mass - absorbedOriginalMass;

            if (initialAbsorberMass <= 0.001) { // If absorber was essentially zero mass before this bit
                // Transfer all momentum from the bit being absorbed
                absorber.dx = (absorbed.dx * absorbedOriginalMass) / absorber.mass;
                absorber.dy = (absorbed.dy * absorbedOriginalMass) / absorber.mass;
            } else {
                // Standard momentum conservation: (m1*v1_initial + m2*v2_initial) / (m1 + m2)
                // Here m1 is initialAbsorberMass, m2 is absorbedOriginalMass
                absorber.dx = (initialAbsorberMass * absorber.dx + absorbedOriginalMass * absorbed.dx) / absorber.mass;
                absorber.dy = (initialAbsorberMass * absorber.dy + absorbedOriginalMass * absorbed.dy) / absorber.mass;
            }
            // Ensure velocities don't become NaN if masses are tiny
             if (isNaN(absorber.dx)) absorber.dx = 0;
             if (isNaN(absorber.dy)) absorber.dy = 0;
        }
        // ***** END ADDED FUNCTION *****

        function updateAbsorptions(fixedTimestepMs) { /* ... game's function ... */ if (fixedTimestepMs <= 0) return; const dtSeconds = fixedTimestepMs / 1000.0; for (let [absorbedId, absorptionInfo] of activeAbsorptions) { const { absorber, absorbed } = absorptionInfo; const currentAbsorber = absorber.isPlayer ? player : orbs.find(o => o.id === absorber.id); const currentAbsorbed = absorbed.isPlayer ? player : orbs.find(o => o.id === absorbed.id); if (!currentAbsorber || orbsToRemove.has(absorber.id) || !currentAbsorbed || orbsToRemove.has(absorbed.id)) { activeAbsorptions.delete(absorbedId); continue; } const dist = wrappedDistance(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const radiiSum = currentAbsorber.radius + currentAbsorbed.radius; const overlap = Math.max(0, radiiSum - dist); if (overlap >= 0 && dist <= radiiSum + 0.1 && currentAbsorber.mass > currentAbsorbed.mass * MASS_ABSORPTION_RATIO && currentAbsorbed.radius >= MIN_ABSORB_COMPLETE_RADIUS * 0.9) { let approachSpeed = 0; if (dist > 0.1) { const v_rel_x = currentAbsorbed.dx - currentAbsorber.dx; const v_rel_y = currentAbsorbed.dy - currentAbsorber.dy; const disp = getWrappedVector(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const dispMag = Math.sqrt(disp.dx * disp.dx + disp.dy * disp.dy); if (dispMag > 0.01) { const unit_x = disp.dx / dispMag; const unit_y = disp.dy / dispMag; const v_radial = v_rel_x * unit_x + v_rel_y * unit_y; approachSpeed = Math.max(0, -v_radial); } } const overlapRatio = currentAbsorbed.radius > 0.1 ? Math.min(1, overlap / currentAbsorbed.radius) : 1; const overlapFactor = overlapRatio * (MAX_OVERLAP_SPEED_FACTOR - 1.0); const velocityFactor = approachSpeed * (VELOCITY_ABSORPTION_FACTOR / BASE_ABSORPTION_RATE_PER_SECOND); const speedFactor = 1.0 + overlapFactor + velocityFactor; const effectiveAbsorptionRate = BASE_ABSORPTION_RATE_PER_SECOND * speedFactor; let massToTransfer = effectiveAbsorptionRate * dtSeconds; massToTransfer = Math.min(massToTransfer, currentAbsorbed.mass); const oldAbsorberMass = currentAbsorber.mass; const massBeingTransferred = massToTransfer; if (massBeingTransferred > 0) { currentAbsorber.mass += massBeingTransferred; currentAbsorbed.mass -= massBeingTransferred; currentAbsorber.radius = Math.sqrt(currentAbsorber.mass); currentAbsorbed.radius = currentAbsorbed.mass > 0 ? Math.sqrt(currentAbsorbed.mass) : 0; const c1 = parseRGBA(currentAbsorber.color); const c2 = parseRGBA(currentAbsorbed.color); const newTotalMass = currentAbsorber.mass; if (newTotalMass > 0) { const newR = Math.round((c1.r * oldAbsorberMass + c2.r * massBeingTransferred) / newTotalMass); const newG = Math.round((c1.g * oldAbsorberMass + c2.g * massBeingTransferred) / newTotalMass); const newB = Math.round((c1.b * oldAbsorberMass + c2.b * massBeingTransferred) / newTotalMass); const newA = (c1.a * oldAbsorberMass + c2.a * massBeingTransferred) / newTotalMass; currentAbsorber.color = `rgba(${Math.max(0,Math.min(255,newR))}, ${Math.max(0,Math.min(255,newG))}, ${Math.max(0,Math.min(255,newB))}, ${Math.max(0.1,Math.min(1,newA)).toFixed(2)})`; } } const newRadiiSum = currentAbsorber.radius + currentAbsorbed.radius; const newDist = wrappedDistance(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const penetration = Math.max(0, newRadiiSum - newDist); if (penetration > 0.05 && newDist > 0.05) { const vector = getWrappedVector(currentAbsorber.x, currentAbsorber.y, currentAbsorbed.x, currentAbsorbed.y, canvasWidth, canvasHeight); const vectorMag = Math.sqrt(vector.dx * vector.dx + vector.dy * vector.dy); if (vectorMag > 0.01) { const nudgeFactor = penetration / vectorMag; const totalMassForNudge = currentAbsorber.mass + currentAbsorbed.mass; if (totalMassForNudge > 0.01) { const nudgeAbsorbedX = vector.dx * nudgeFactor * (currentAbsorber.mass / totalMassForNudge); const nudgeAbsorbedY = vector.dy * nudgeFactor * (currentAbsorber.mass / totalMassForNudge); const nudgeAbsorberX = -vector.dx * nudgeFactor * (currentAbsorbed.mass / totalMassForNudge); const nudgeAbsorberY = -vector.dy * nudgeFactor * (currentAbsorbed.mass / totalMassForNudge); currentAbsorbed.x = (currentAbsorbed.x + nudgeAbsorbedX + canvasWidth) % canvasWidth; currentAbsorbed.y = (currentAbsorbed.y + nudgeAbsorbedY + canvasHeight) % canvasHeight; currentAbsorber.x = (currentAbsorber.x + nudgeAbsorberX + canvasWidth) % canvasWidth; currentAbsorber.y = (currentAbsorber.y + nudgeAbsorberY + canvasHeight) % canvasHeight; } } } if (currentAbsorbed.radius <= MIN_ABSORB_COMPLETE_RADIUS || currentAbsorbed.mass <= 0.01) { const remainingMass = currentAbsorbed.mass; if (remainingMass > 0) { currentAbsorber.mass += remainingMass; currentAbsorber.radius = Math.sqrt(currentAbsorber.mass); }
             // *** THIS IS WHERE THE FUNCTION IS CALLED ***
             mixMomentumOnAbsorption(currentAbsorber, currentAbsorbed, massBeingTransferred + remainingMass);
             // *** END FUNCTION CALL ***
             if (currentAbsorbed.isPlayer) { playerAbsorbed = true; console.log("Player orb fully absorbed (radius <= threshold). Reset pending."); } orbsToRemove.add(absorbedId); activeAbsorptions.delete(absorbedId); currentAbsorbed.mass = 0; currentAbsorbed.radius = 0; currentAbsorbed.dx = 0; currentAbsorbed.dy = 0; } } else { activeAbsorptions.delete(absorbedId); } } }
        function resolveElasticCollision(orb1, orb2, dist, width, height) { /* ... game's function ... */ if (dist < 0.01) { const angle = Math.random() * Math.PI * 2; const nudge = 0.1; orb1.x = (orb1.x - Math.cos(angle) * nudge + width) % width; orb1.y = (orb1.y - Math.sin(angle) * nudge + height) % height; orb2.x = (orb2.x + Math.cos(angle) * nudge + width) % width; orb2.y = (orb2.y + Math.sin(angle) * nudge + height) % height; return; } const vec = getWrappedVector(orb1.x, orb1.y, orb2.x, orb2.y, width, height); const nx = vec.dx / dist; const ny = vec.dy / dist; const rvx = orb2.dx - orb1.dx; const rvy = orb2.dy - orb1.dy; const velAlongNormal = rvx * nx + rvy * ny; if (velAlongNormal >= 0) { return; } const tx = -ny; const ty = nx; const v1n_scalar = orb1.dx * nx + orb1.dy * ny; const v1t_scalar = orb1.dx * tx + orb1.dy * ty; const v2n_scalar = orb2.dx * nx + orb2.dy * ny; const v2t_scalar = orb2.dx * tx + orb2.dy * ty; const v1n_scalar_new = v2n_scalar; const v2n_scalar_new = v1n_scalar; orb1.dx = (v1n_scalar_new * nx) + (v1t_scalar * tx); orb1.dy = (v1n_scalar_new * ny) + (v1t_scalar * ty); orb2.dx = (v2n_scalar_new * nx) + (v2t_scalar * tx); orb2.dy = (v2n_scalar_new * ny) + (v2t_scalar * ty); const radiiSum = orb1.radius + orb2.radius; const penetration = Math.max(0, radiiSum - dist); if (penetration > 0.01) { const nudgeAmount = (penetration / 2) + 0.01; orb1.x = (orb1.x - nx * nudgeAmount + width) % width; orb1.y = (orb1.y - ny * nudgeAmount + height) % height; orb2.x = (orb2.x + nx * nudgeAmount + width) % width; orb2.y = (orb2.y + ny * nudgeAmount + height) % height; } if (activeAbsorptions.has(orb1.id) && activeAbsorptions.get(orb1.id).absorber.id === orb2.id) { activeAbsorptions.delete(orb1.id); } if (activeAbsorptions.has(orb2.id) && activeAbsorptions.get(orb2.id).absorber.id === orb1.id) { activeAbsorptions.delete(orb2.id); } }
        function checkCollisions() { /* ... game's function ... */ if (!player && !playerAbsorbed) return; const width = canvasWidth; const height = canvasHeight; const allOrbs = player && !playerAbsorbed && player.mass > 0 ? [player, ...orbs.filter(o => !orbsToRemove.has(o.id))] : [...orbs.filter(o => !orbsToRemove.has(o.id))]; const checkedPairs = new Set(); for (let i = allOrbs.length - 1; i >= 0; i--) { const orb1 = allOrbs[i]; if (!orb1 || orb1.mass <= 0 || orbsToRemove.has(orb1.id)) continue; for (let j = i - 1; j >= 0; j--) { const orb2 = allOrbs[j]; if (!orb2 || orb2.mass <= 0 || orbsToRemove.has(orb2.id)) continue; const pairKey = orb1.id < orb2.id ? `${orb1.id}-${orb2.id}` : `${orb2.id}-${orb1.id}`; if (checkedPairs.has(pairKey)) continue; checkedPairs.add(pairKey); const dist = wrappedDistance(orb1.x, orb1.y, orb2.x, orb2.y, width, height); const radiiSum = orb1.radius + orb2.radius; if (dist <= radiiSum + 0.5) { let absorber = null, absorbed = null; if (orb1.mass > orb2.mass * MASS_ABSORPTION_RATIO && orb1.radius > orb2.radius) { absorber = orb1; absorbed = orb2; } else if (orb2.mass > orb1.mass * MASS_ABSORPTION_RATIO && orb2.radius > orb1.radius) { absorber = orb2; absorbed = orb1; } if (absorber && absorbed) { const reverseAbsorption = activeAbsorptions.get(absorber.id); if (reverseAbsorption && reverseAbsorption.absorber.id === absorbed.id) { activeAbsorptions.delete(absorber.id); } const existingAbsorption = activeAbsorptions.get(absorbed.id); if (!existingAbsorption || existingAbsorption.absorber.id !== absorber.id) { activeAbsorptions.set(absorbed.id, { absorber: absorber, absorbed: absorbed }); } } else { resolveElasticCollision(orb1, orb2, dist, width, height); } } else { const absorption12 = activeAbsorptions.get(orb2.id); if (absorption12 && absorption12.absorber.id === orb1.id) { activeAbsorptions.delete(orb2.id); } const absorption21 = activeAbsorptions.get(orb1.id); if (absorption21 && absorption21.absorber.id === orb2.id) { activeAbsorptions.delete(orb1.id); } } } } }

        // --- Player Control ---
        function propelPlayer(targetScreenX, targetScreenY) { /* ... game's function ... */ if (!player || player.radius <= MIN_PLAYER_RADIUS || playerAbsorbed) return false; const width = canvasWidth; const height = canvasHeight; const targetWorldX = player.x + (targetScreenX - width / 2); const targetWorldY = player.y + (targetScreenY - height / 2); const vec = getWrappedVector(player.x, player.y, targetWorldX, targetWorldY, width, height); let dx = vec.dx; let dy = vec.dy; if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) return false; const angleToTarget = Math.atan2(dy, dx); const ejectionAngle = angleToTarget; const propulsionAngle = angleToTarget + Math.PI; const massToEject = player.mass * EJECTION_MASS_RATIO; if (massToEject <= 0) return false; const radiusEjected = Math.sqrt(massToEject); if (radiusEjected < MIN_ORB_RADIUS * 0.5) return false; const potentialNewPlayerMass = player.mass - massToEject; if (potentialNewPlayerMass < (MIN_PLAYER_RADIUS * MIN_PLAYER_RADIUS)) { return false; } const baseEjectionSpeed = EJECTION_SPEED_MULTIPLIER; const ejectVelX = player.dx + Math.cos(ejectionAngle) * baseEjectionSpeed; const ejectVelY = player.dy + Math.sin(ejectionAngle) * baseEjectionSpeed; const playerNewRadiusIfEjected = Math.sqrt(potentialNewPlayerMass); const effectivePlayerRadiusForPlacement = Math.max(MIN_PLAYER_RADIUS, playerNewRadiusIfEjected); const startDist = effectivePlayerRadiusForPlacement + radiusEjected + 1.5; const ejectStartRawX = player.x + Math.cos(ejectionAngle) * startDist; const ejectStartRawY = player.y + Math.sin(ejectionAngle) * startDist; const ejectStartX = (ejectStartRawX % width + width) % width; const ejectStartY = (ejectStartRawY % height + height) % height; const playerBaseColor = parseRGBA(player.color); const ejectAlpha = Math.max(0.2, playerBaseColor.a * 0.7).toFixed(2); const ejectColor = `rgba(${playerBaseColor.r}, ${playerBaseColor.g}, ${playerBaseColor.b}, ${ejectAlpha})`; const particle = createOrb(ejectStartX, ejectStartY, radiusEjected, ejectVelX, ejectVelY, ejectColor); if (particle && particle.mass > 0) { orbs.push(particle); } else { console.warn("Ejected particle invalid mass or creation failed."); return false; } player.mass = potentialNewPlayerMass; player.radius = Math.max(MIN_PLAYER_RADIUS, Math.sqrt(player.mass)); const impulseMagnitude = massToEject * baseEjectionSpeed; if (player.mass > 0) { const thrustX = Math.cos(propulsionAngle) * impulseMagnitude / player.mass; const thrustY = Math.sin(propulsionAngle) * impulseMagnitude / player.mass; player.dx += thrustX; player.dy += thrustY; } return true; }

        // QUOTE: Typing Animation Logic (uses setTimeout, separate from gameLoop)
        function quoteTypeCharacter() { /* ... quote's typeCharacter function ... */ if (quoteState !== 'typing' || !currentQuote || currentQuote.isCorrectingTypo) return; if (currentQuote.currentIndex >= currentQuote.fullText.length) { currentQuote.isComplete = true; currentQuote.completionTime = Date.now(); quoteState = 'paused'; console.log("QUOTE: Finished typing. Pausing sound & starting pre-fade pause..."); quoteTypingSound.pause(); return; } const targetChar = currentQuote.fullText[currentQuote.currentIndex]; const makeTypo = Math.random() < QUOTE_TYPO_CHANCE && targetChar !== '\n' && !(targetChar === '—' && currentQuote.currentIndex === currentQuote.fullText.lastIndexOf('\n') + 1); if (makeTypo) { currentQuote.isCorrectingTypo = true; const typoChars = 'abcdefghijklmnopqrstuvwxyz'; const typoChar = typoChars[Math.floor(Math.random() * typoChars.length)]; currentQuote.typedText += typoChar; setTimeout(() => { if (currentQuote && currentQuote.typedText) currentQuote.typedText = currentQuote.typedText.slice(0, -1); setTimeout(() => { if (currentQuote) { currentQuote.typedText += targetChar; currentQuote.currentIndex++; currentQuote.isCorrectingTypo = false; quoteScheduleNextChar(); } }, QUOTE_BACKSPACE_DELAY_MS / 2); }, QUOTE_TYPO_DELAY_MS); } else { currentQuote.typedText += targetChar; currentQuote.currentIndex++; quoteScheduleNextChar(); } }
        function quoteScheduleNextChar() { /* ... quote's scheduleNextChar function ... */ if (quoteState !== 'typing' || !currentQuote || currentQuote.isComplete) return; const delay = QUOTE_TYPING_SPEED_MS + (Math.random() * QUOTE_TYPING_SPEED_MS * 0.4) - (QUOTE_TYPING_SPEED_MS * 0.2); setTimeout(quoteTypeCharacter, Math.max(20, delay)); }
        function quoteStartNew() { /* ... quote's startNewQuote function (zone placement) ... */ if (quotesData.length === 0 || (quoteState !== 'idle' && quoteState !== 'loading') || currentQuote !== null) { /* ... checks ... */ return; } if (quoteNextQuoteTimeoutId) { clearTimeout(quoteNextQuoteTimeoutId); quoteNextQuoteTimeoutId = null; } console.log("QUOTE: Starting new quote process..."); const randomIndex = Math.floor(Math.random() * quotesData.length); const selectedQuote = quotesData[randomIndex]; const formatted = quoteFormatText(selectedQuote.quote, selectedQuote.author); if(!formatted || formatted.quoteLines.length === 0) { console.error("QUOTE: Failed to format quote, skipping:", selectedQuote); setTimeout(quoteStartNew, 50); return; } const estHeight = (formatted.totalQuoteLines + 1) * QUOTE_LINE_HEIGHT; const estWidth = Math.max(formatted.maxQuoteLineWidth, formatted.authorLineWidth) + QUOTE_OUTLINE_WIDTH * 2; const excludeZoneWidth = canvasWidth * QUOTE_CENTER_EXCLUSION_FACTOR_X; const excludeZoneHeight = canvasHeight * QUOTE_CENTER_EXCLUSION_FACTOR_Y; const excludeZoneLeft = (canvasWidth - excludeZoneWidth) / 2; const excludeZoneRight = excludeZoneLeft + excludeZoneWidth; const excludeZoneTop = (canvasHeight - excludeZoneHeight) / 2; const excludeZoneBottom = excludeZoneTop + excludeZoneHeight; let x = QUOTE_PADDING; let y = QUOTE_PADDING; let attempts = 0; let placementSuccessful = false; const MAX_ZONE_ATTEMPTS = QUOTE_MAX_PLACEMENT_ATTEMPTS; while (attempts < MAX_ZONE_ATTEMPTS && !placementSuccessful) { attempts++; const zoneIndex = Math.floor(Math.random() * 4); let zoneMinX = QUOTE_PADDING, zoneMaxX = QUOTE_PADDING, zoneMinY = QUOTE_PADDING, zoneMaxY = QUOTE_PADDING; let zoneIsValid = false; switch (zoneIndex) { case 0: zoneMinX = QUOTE_PADDING; zoneMaxX = canvasWidth - estWidth - QUOTE_PADDING; zoneMinY = QUOTE_PADDING; zoneMaxY = excludeZoneTop - estHeight - QUOTE_PADDING; if (zoneMaxX > zoneMinX && zoneMaxY > zoneMinY) zoneIsValid = true; break; case 1: zoneMinX = QUOTE_PADDING; zoneMaxX = canvasWidth - estWidth - QUOTE_PADDING; zoneMinY = excludeZoneBottom + QUOTE_PADDING; zoneMaxY = canvasHeight - estHeight - QUOTE_PADDING; if (zoneMaxX > zoneMinX && zoneMaxY > zoneMinY) zoneIsValid = true; break; case 2: zoneMinX = QUOTE_PADDING; zoneMaxX = excludeZoneLeft - estWidth - QUOTE_PADDING; zoneMinY = excludeZoneTop + QUOTE_PADDING; zoneMaxY = excludeZoneBottom - estHeight - QUOTE_PADDING; if (zoneMaxX > zoneMinX && zoneMaxY > zoneMinY) zoneIsValid = true; break; case 3: zoneMinX = excludeZoneRight + QUOTE_PADDING; zoneMaxX = canvasWidth - estWidth - QUOTE_PADDING; zoneMinY = excludeZoneTop + QUOTE_PADDING; zoneMaxY = excludeZoneBottom - estHeight - QUOTE_PADDING; if (zoneMaxX > zoneMinX && zoneMaxY > zoneMinY) zoneIsValid = true; break; } if (zoneIsValid) { x = zoneMinX + Math.random() * (zoneMaxX - zoneMinX); y = zoneMinY + Math.random() * (zoneMaxY - zoneMinY); placementSuccessful = true; } } if (!placementSuccessful) { console.warn(`QUOTE: Could not find a suitable zone/position after ${attempts} attempts. Defaulting to top-left.`); } currentQuote = { ...formatted, x: Math.max(QUOTE_PADDING, x), y: Math.max(QUOTE_PADDING, y), typedText: '', currentIndex: 0, isComplete: false, isCorrectingTypo: false, completionTime: null, fadeStartTime: null }; console.log("QUOTE: Attempting to play/resume typing sound..."); const playPromise = quoteTypingSound.play(); if (playPromise !== undefined) { playPromise.catch(error => console.warn("QUOTE: Audio play failed:", error)); } quoteState = 'typing'; quoteScheduleNextChar(); }

        // --- Combined Game Loop ---
        function gameLoop(currentTime) { /* ... combined loop as before ... */
             if (!gameLastTimestamp) gameLastTimestamp = currentTime; let deltaTime = currentTime - gameLastTimestamp; gameLastTimestamp = currentTime; deltaTime = Math.min(deltaTime, MAX_ACCUMULATED_TIME_MS * 2); if (isInteractionActive && player && !playerAbsorbed) { if (currentTime - lastPropulsionTime > PROPULSION_COOLDOWN) { if (propelPlayer(lastInteractionX, lastInteractionY)) { lastPropulsionTime = currentTime; } } } gameTimeAccumulator += deltaTime; gameTimeAccumulator = Math.min(gameTimeAccumulator, MAX_ACCUMULATED_TIME_MS); while (gameTimeAccumulator >= FIXED_TIMESTEP_MS) { if (player && player.mass > 0) updateOrb(player, FIXED_TIMESTEP_S); orbs.forEach(orb => { if (!orbsToRemove.has(orb.id)) updateOrb(orb, FIXED_TIMESTEP_S); }); updateAbsorptions(FIXED_TIMESTEP_MS); gameTimeAccumulator -= FIXED_TIMESTEP_MS; } checkCollisions(); if (orbsToRemove.size > 0) { orbs = orbs.filter(orb => !orbsToRemove.has(orb.id)); activeAbsorptions.forEach((value, key) => { if (orbsToRemove.has(key)) { activeAbsorptions.delete(key); } }); orbsToRemove.clear(); } if (playerAbsorbed) { console.log("GAME: Executing reset due to player absorption."); if (bgMusic && !bgMusic.paused) { bgMusic.pause(); bgMusic.currentTime = 0; musicStarted = false; } if (quoteTypingSound && !quoteTypingSound.paused) { quoteTypingSound.pause(); } if (gameAnimationFrameId) { cancelAnimationFrame(gameAnimationFrameId); gameAnimationFrameId = null; } initializeGame(false); return; } if (currentQuote) { if (quoteState === 'fading') { const elapsed = currentTime - currentQuote.fadeStartTime; const fadeProgress = Math.min(1, elapsed / QUOTE_FADE_DURATION_MS); if (fadeProgress >= 1) { console.log(`QUOTE: Fade out complete. Starting ${QUOTE_INTER_QUOTE_PAUSE_MS / 1000}s pause...`); currentQuote = null; quoteState = 'waiting_for_next'; if (quoteNextQuoteTimeoutId) clearTimeout(quoteNextQuoteTimeoutId); quoteNextQuoteTimeoutId = setTimeout(() => { quoteNextQuoteTimeoutId = null; quoteState = 'idle'; quoteStartNew(); }, QUOTE_INTER_QUOTE_PAUSE_MS); } } else if (quoteState === 'paused') { if (Date.now() - currentQuote.completionTime >= QUOTE_PAUSE_DURATION_MS) { console.log("QUOTE: Pause (before fade) finished. Starting fade out..."); currentQuote.fadeStartTime = currentTime; quoteState = 'fading'; } } } ctx.clearRect(0, 0, canvasWidth, canvasHeight); const drawOffsetX = (player && player.mass > 0) ? player.x - canvasWidth / 2 : canvasWidth / 2; const drawOffsetY = (player && player.mass > 0) ? player.y - canvasHeight / 2 : canvasHeight / 2; ctx.save(); orbs.forEach(orb => drawOrbWithWrapping(orb, drawOffsetX, drawOffsetY)); if (player && player.radius >= MIN_ABSORB_COMPLETE_RADIUS) { drawOrbWithWrapping(player, drawOffsetX, drawOffsetY); } ctx.restore(); if (currentQuote) { if (quoteState === 'fading') { const elapsed = currentTime - currentQuote.fadeStartTime; const fadeProgress = Math.min(1, elapsed / QUOTE_FADE_DURATION_MS); const alpha = 1.0 - fadeProgress; quoteDrawState(currentQuote, alpha); } else if (quoteState === 'typing' || quoteState === 'paused') { quoteDrawState(currentQuote, 1.0); } } else { if (quoteState === 'loading') { quoteDisplayStatusMessage("Loading quotes..."); } else if (quoteState === 'waiting_for_next') { /* quoteDisplayStatusMessage(`Waiting...`); */ } else if (quoteState === 'idle' && quoteInitialLoadComplete) { /* quoteDisplayStatusMessage("Ready..."); */ } else if (!quoteInitialLoadComplete && quoteState !== 'error') { /* quoteDisplayStatusMessage("Initializing..."); */ } } if (!playerAbsorbed) { gameAnimationFrameId = requestAnimationFrame(gameLoop); }
         }

        // --- Game Orb Spawning ---
        function spawnOrbs(count) { /* ... game's function ... */ console.log(`Spawning ${count} orbs... Max speed: ${INITIAL_ORB_MAX_SPEED}`); if (typeof canvasWidth === 'undefined' || typeof canvasHeight === 'undefined') { console.error("Cannot spawn orbs: canvas dimensions not yet initialized."); return; } const existingOrbsAndPlayer = player ? [...orbs, player] : [...orbs]; let spawnedCount = 0; for (let i = 0; i < count; i++) { let r, x, y; let tooClose; let attempts = 0; const maxAttempts = 100; do { r = Math.random() * (MAX_ORB_RADIUS - MIN_ORB_RADIUS) + MIN_ORB_RADIUS; x = Math.random() * canvasWidth; y = Math.random() * canvasHeight; tooClose = false; for (const existing of existingOrbsAndPlayer) { const checkDist = wrappedDistance(x, y, existing.x, existing.y, canvasWidth, canvasHeight); const requiredDist = (existing.radius + r) * 1.1 + (existing.isPlayer ? SAFE_ZONE_RADIUS : 5); if (checkDist < requiredDist) { tooClose = true; break; } } attempts++; } while (tooClose && attempts < maxAttempts); if (!tooClose) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * INITIAL_ORB_MAX_SPEED; const newOrb = createOrb(x, y, r, Math.cos(angle) * speed, Math.sin(angle) * speed); if (newOrb) { orbs.push(newOrb); existingOrbsAndPlayer.push(newOrb); spawnedCount++; } } } console.log(`Successfully spawned ${spawnedCount} / ${count} orbs.`); }

        // --- Initialization ---
        function initializeGame(isResize = false) { /* ... game's init function ... */ console.log(`GAME: Initializing game... ${isResize ? '(Resize)' : ''}`); if (gameAnimationFrameId) { cancelAnimationFrame(gameAnimationFrameId); gameAnimationFrameId = null; } if (!canvas || !ctx) { console.error("CRITICAL: Canvas or context missing!"); return; } const prevWidth = typeof canvasWidth !== 'undefined' ? canvasWidth : window.innerWidth; const prevHeight = typeof canvasHeight !== 'undefined' ? canvasHeight : window.innerHeight; try { canvasWidth = window.innerWidth; canvasHeight = window.innerHeight; canvas.width = canvasWidth; canvas.height = canvasHeight; ctx.font = `${QUOTE_FONT_SIZE}px ${QUOTE_FONT_FAMILY}`; ctx.textBaseline = 'top'; ctx.lineJoin = 'round'; } catch (e) { console.error("Error setting canvas dimensions:", e); return; } if (!isResize || !player || playerAbsorbed) { console.log("GAME: Full reset required."); orbs = []; player = null; activeAbsorptions.clear(); orbsToRemove.clear(); if (bgMusic && !bgMusic.paused) { bgMusic.pause(); bgMusic.currentTime = 0; } musicStarted = false; player = createOrb(canvasWidth / 2, canvasHeight / 2, 20, 0, 0, 'rgba(100, 200, 255, 0.9)'); if (!player || typeof player !== 'object') { console.error("CRITICAL ERROR: Player creation failed!"); return; } player.isPlayer = true; spawnOrbs(INITIAL_ORBS); } else { console.log(`GAME: Resizing canvas from ${prevWidth}x${prevHeight} to ${canvasWidth}x${canvasHeight}`); player.x = canvasWidth / 2; player.y = canvasHeight / 2; activeAbsorptions.clear(); orbsToRemove.clear(); } isInteractionActive = false; gameLastTimestamp = 0; gameTimeAccumulator = 0; playerAbsorbed = false; console.log("GAME: Initialization complete, requesting loop..."); if (gameAnimationFrameId) { cancelAnimationFrame(gameAnimationFrameId); gameAnimationFrameId = null; } gameAnimationFrameId = requestAnimationFrame(gameLoop); }
        async function initializeQuotes() { /* ... quote's initialize function ... */ quoteState = 'loading'; try { quoteTypingSound.play().then(() => { quoteTypingSound.pause(); }).catch(() => { console.warn("QUOTE: Audio context likely requires user interaction."); }); const response = await fetch('quotes.csv'); if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to fetch quotes.csv`); const csvText = await response.text(); quotesData = quoteParseCSV(csvText); if (!quotesData || quotesData.length === 0) throw new Error("No valid quotes found in quotes.csv"); console.log(`QUOTE: Loaded ${quotesData.length} quotes.`); quoteInitialLoadComplete = true; quoteState = 'idle'; console.log("QUOTE: Initialization complete. First quote will start after initial pause/trigger."); if (quoteNextQuoteTimeoutId) clearTimeout(quoteNextQuoteTimeoutId); quoteNextQuoteTimeoutId = setTimeout(() => { quoteNextQuoteTimeoutId = null; quoteState = 'idle'; quoteStartNew(); }, QUOTE_INTER_QUOTE_PAUSE_MS); } catch (error) { console.error("QUOTE: Initialization failed:", error); quoteState = 'error'; quoteDisplayError(`Quote Error: ${error.message}. Check quotes.csv & keyclicks.mp3 exists?`); } }

        // --- Web Audio Setup (Game) ---
        function setupAudioAnalysis() { /* ... game's function ... */ if (!audioContext) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext created."); } catch (e) { console.error("Web Audio API is not supported in this browser", e); return; } } if (audioContext.state === 'suspended') { audioContext.resume(); } if (audioContext && !sourceNode) { try { sourceNode = audioContext.createMediaElementSource(bgMusic); analyser = audioContext.createAnalyser(); analyser.fftSize = ANALYSER_FFT_SIZE; analyser.smoothingTimeConstant = ANALYSER_SMOOTHING; audioDataArray = new Uint8Array(analyser.frequencyBinCount); sourceNode.connect(analyser); analyser.connect(audioContext.destination); console.log("Web Audio nodes connected for analysis."); } catch (e) { console.error("Error setting up audio analysis nodes:", e); sourceNode = null; analyser = null; audioDataArray = null; } } }

        // --- Event Listeners (Mouse & Touch - Combined Audio Unlock) ---
        function getCanvasCoordinates(event) { /* ... game's function ... */ if (event.target && event.target.closest && event.target.closest('#hamburger-menu')) { return null; } const rect = canvas.getBoundingClientRect(); let clientX, clientY; if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.changedTouches && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else { clientX = event.clientX; clientY = event.clientY; } if (clientX === undefined || clientY === undefined) return null; return { x: clientX - rect.left, y: clientY - rect.top }; }
        function handleInteractionStart(event) { /* ... game's function ... */ if (bgMusic && !musicStarted) { console.log("First interaction detected, attempting to play game music..."); const playPromise = bgMusic.play(); if (playPromise !== undefined) { playPromise.then(_ => { console.log("Background music started successfully."); musicStarted = true; setupAudioAnalysis(); }).catch(error => { console.warn("Background music play() failed:", error); }); } else { console.warn("bgMusic.play() did not return a promise. Assuming playback started."); musicStarted = true; setupAudioAnalysis(); } } else if (musicStarted && audioContext && audioContext.state === 'suspended') { audioContext.resume().then(() => { console.log("AudioContext resumed on interaction."); }).catch(e => console.error("Error resuming AudioContext", e)); } if (quoteTypingSound && quoteTypingSound.paused) { console.log("Interaction detected, attempting quote audio unlock..."); quoteTypingSound.play().then(()=>quoteTypingSound.pause()).catch(()=>{}); } const coords = getCanvasCoordinates(event); if (!coords) return; if (event.type === 'touchstart') { event.preventDefault(); } isInteractionActive = true; lastInteractionX = coords.x; lastInteractionY = coords.y; if (player && !playerAbsorbed && Date.now() - lastPropulsionTime > PROPULSION_COOLDOWN) { if (propelPlayer(lastInteractionX, lastInteractionY)) { lastPropulsionTime = Date.now(); } } }
        function handleInteractionMove(event) { /* ... game's function ... */ if (!isInteractionActive) return; const coords = getCanvasCoordinates(event); if (!coords) return; if (event.type === 'touchmove') { event.preventDefault(); } lastInteractionX = coords.x; lastInteractionY = coords.y; }
        function handleInteractionEnd(event) { /* ... game's function ... */ const targetIsCanvas = !event.target || !event.target.closest || !event.target.closest('#hamburger-menu'); if (targetIsCanvas && (event.type === 'touchend' || event.type === 'touchcancel')) { if (event.cancelable) { event.preventDefault(); } } isInteractionActive = false; }
        canvas.addEventListener('mousedown', handleInteractionStart); canvas.addEventListener('mousemove', handleInteractionMove); window.addEventListener('mouseup', handleInteractionEnd); window.addEventListener('mouseleave', handleInteractionEnd); canvas.addEventListener('touchstart', handleInteractionStart, { passive: false }); canvas.addEventListener('touchmove', handleInteractionMove, { passive: false }); window.addEventListener('touchend', handleInteractionEnd, { passive: false }); window.addEventListener('touchcancel', handleInteractionEnd, { passive: false });
        let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { console.log("Window resize detected."); initializeGame(true); }, 250); });

        // --- Fullscreen Toggle Logic --- (Game's logic)
        const hamburgerMenu = document.getElementById('hamburger-menu'); const docElement = document.documentElement; function isFullScreen() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); } function toggleFullScreen() { if (!isFullScreen()) { console.log("Requesting fullscreen..."); if (docElement.requestFullscreen) { docElement.requestFullscreen().catch(err => console.error(`Error attempting FScr: ${err.message} (${err.name})`)); } else if (docElement.webkitRequestFullscreen) { docElement.webkitRequestFullscreen().catch(err => console.error(`Error attempting FScr (webkit): ${err.message} (${err.name})`)); } else if (docElement.msRequestFullscreen) { docElement.msRequestFullscreen().catch(err => console.error(`Error attempting FScr (ms): ${err.message} (${err.name})`)); } else { console.warn("Fullscreen API is not supported by this browser."); } } else { console.log("Exiting fullscreen..."); if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } else { console.warn("Exit Fullscreen API is not supported?"); } } }
        if (hamburgerMenu) { hamburgerMenu.addEventListener('click', toggleFullScreen); hamburgerMenu.addEventListener('touchstart', (e) => { e.preventDefault(); toggleFullScreen(); }, { passive: false }); } else { console.error("Hamburger menu element not found!"); } document.addEventListener('fullscreenchange', () => { console.log('Fullscreen state changed (std)'); }); document.addEventListener('webkitfullscreenchange', () => { console.log('Fullscreen state changed (webkit)'); }); document.addEventListener('mozfullscreenchange', () => { console.log('Fullscreen state changed (moz)'); }); document.addEventListener('MSFullscreenChange', () => { console.log('Fullscreen state changed (ms)'); });

        // --- Start Game & Load Quotes ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired.");
            initializeGame(false); // Initialize the game first
            initializeQuotes(); // Then start loading quotes asynchronously
        });

    </script>
</body>
</html>
